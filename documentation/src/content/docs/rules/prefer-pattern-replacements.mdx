---
title: prefer-pattern-replacements
---

import { Code } from "@astrojs/starlight/components";

Enforces replacement of verbose constructor/method patterns with simpler alternatives.

## Rule Details

This rule uses a type-safe pattern matching system to detect verbose constructor or method calls that have simpler equivalents. It supports captures, optional arguments, wildcards, and scope-aware fixes.

## Features

- ✨ Has auto-fix
- Type-safe `pattern()` API with compile-time capture validation
- Supports captures (`$x`, optional args (`0?`), wildcards (`_`)
- Constant expression evaluation (`1 - 1` matches `0`)
- Same-variable matching (`$x, $x` requires identical arguments)
- Scope-aware: skips fix if replacement would shadow local variable

## Options

<Code
	code={[
		'import { pattern } from "@pobammer-ts/eslint-cease-nonsense-rules";',
		"",
		"{",
		'\t"cease-nonsense/prefer-pattern-replacements": [',
		'\t\t"error",',
		"\t\t{",
		'\t\t\t"patterns": [',
		"\t\t\t\t// Simple patterns",
		"\t\t\t\tpattern({",
		'\t\t\t\t\t"match": "UDim2.fromScale(1, 1)",',
		'\t\t\t\t\t"replacement": "oneScale",',
		"\t\t\t\t}),",
		"",
		"\t\t\t\t// Captures and conditions",
		"\t\t\t\tpattern({",
		'\t\t\t\t\t"match": "new Vector2($x, $x)",',
		'\t\t\t\t\t"replacement": "fromUniform($x)",',
		'\t\t\t\t\t"when": { "x": "!= 0" },',
		"\t\t\t\t}),",
		"",
		"\t\t\t\t// Optional args (0? matches 0 or missing)",
		"\t\t\t\tpattern({",
		'\t\t\t\t\t"match": "new Vector2($x, 0?)",',
		'\t\t\t\t\t"replacement": "fromX($x)",',
		"\t\t\t\t}),",
		"",
		"\t\t\t\t// Wildcards (match any value, don't capture)",
		"\t\t\t\tpattern({",
		'\t\t\t\t\t"match": "new UDim2(_, 0, _, 0)",',
		'\t\t\t\t\t"replacement": "UDim2.fromScale",',
		"\t\t\t\t}),",
		"\t\t\t],",
		"\t\t},",
		"\t],",
		"}",
	].join("\n")}
	lang="typescript"
	key="import-pattern-from--17itsy"
/>

## Pattern Syntax

### Captures: `$name`

Capture a value to use in the replacement:

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $y)",',
		'\treplacement: "Vector2.create($x, $y)",',
		"});",
		"",
		"// new Vector2(10, 20) → Vector2.create(10, 20)",
	].join("\n")}
	lang="typescript"
	key="pattern-398sue"
/>

### Optional Arguments: `0?`

Match literal `0` or missing argument:

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, 0?)",',
		'\treplacement: "fromX($x)",',
		"});",
		"",
		"// new Vector2(5, 0) → fromX(5)",
		"// new Vector2(5) → fromX(5)",
	].join("\n")}
	lang="typescript"
	key="pattern-2j0cmb"
/>

### Wildcards: `_`

Match any value without capturing:

<Code
	code={[
		"pattern({",
		'\tmatch: "new Color3(_, _, 0)",',
		'\treplacement: "Color3.fromRGB",',
		"});",
		"",
		"// new Color3(255, 128, 0) → Color3.fromRGB (matched)",
		"// new Color3(255, 128, 64) → (no match)",
	].join("\n")}
	lang="typescript"
	key="pattern-1eb8m3"
/>

### Conditions: `when`

Add constraints on captured values:

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $x)",',
		'\treplacement: "fromUniform($x)",',
		'\twhen: { x: "!= 0" },',
		"});",
		"",
		"// new Vector2(5, 5) → fromUniform(5)",
		"// new Vector2(0, 0) → (no match, when condition fails)",
	].join("\n")}
	lang="typescript"
	key="pattern-3qsf8w"
/>

Supported operators: `==`, `!=`, `>`, `<`, `>=`, `<=`

### Same-Variable Matching

Using the same capture variable name requires identical values:

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $x)",',
		'\treplacement: "fromUniform($x)",',
		"});",
		"",
		"// new Vector2(5, 5) → fromUniform(5) ✓",
		"// new Vector2(5, 10) → (no match, values differ) ✗",
	].join("\n")}
	lang="typescript"
	key="pattern-v9dnwl"
/>

## Replacement Types

### Identifier

<Code
	code={[
		"pattern({",
		'\tmatch: "UDim2.fromScale(1, 1)",',
		'\treplacement: "oneScale",',
		"});",
		"",
		"// UDim2.fromScale(1, 1) → oneScale",
	].join("\n")}
	lang="typescript"
	key="pattern-c9zwzh"
/>

### Static Access

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2(1, 1)",',
		'\treplacement: "Vector2.one",',
		"});",
		"",
		"// new Vector2(1, 1) → Vector2.one",
	].join("\n")}
	lang="typescript"
	key="pattern-15qonz"
/>

### Call Expression

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $x)",',
		'\treplacement: "fromUniform($x)",',
		"});",
		"",
		"// new Vector2(5, 5) → fromUniform(5)",
	].join("\n")}
	lang="typescript"
	key="pattern-2hxg7x"
/>

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $y)",',
		'\treplacement: "Vector2.create($x, $y)",',
		"});",
		"",
		"// new Vector2(10, 20) → Vector2.create(10, 20)",
	].join("\n")}
	lang="typescript"
	key="pattern-398sue"
/>

## Examples

### ❌ Incorrect

<Code
	code={[
		"const scale = UDim2.fromScale(1, 1);",
		"const vec = new Vector2(5, 5);",
		"const offset = new Vector2(10, 0);",
		"const color = new Color3(255, 0, 0);",
	].join("\n")}
	lang="typescript"
	key="const-scale-udim2-fr-ddr9ty"
/>

### ✅ Correct

<Code
	code={[
		"const scale = oneScale;",
		"const vec = fromUniform(5);",
		"const offset = fromX(10);",
		"const color = Color3.fromRGB(255, 0, 0);",
	].join("\n")}
	lang="typescript"
	key="const-scale-onescale-3gqnl6"
/>

## Scope Awareness

The rule automatically skips fixes when the replacement would conflict with a local variable:

<Code
	code={[
		"function example() {",
		"\tconst oneScale = 5; // Local variable shadows replacement",
		"\tconst scale = UDim2.fromScale(1, 1); // No fix applied (would shadow)",
		"}",
		"",
		"function other() {",
		"\tconst scale = UDim2.fromScale(1, 1); // Fix applied: oneScale",
		"}",
	].join("\n")}
	lang="typescript"
	key="function-example-y5n4i3"
/>

## Common Patterns

### Roblox UDim2

<Code
	code={[
		"pattern({",
		'\tmatch: "UDim2.fromScale(1, 1)",',
		'\treplacement: "oneScale",',
		"});",
		"",
		"pattern({",
		'\tmatch: "UDim2.fromScale(0, 0)",',
		'\treplacement: "zeroScale",',
		"});",
		"",
		"pattern({",
		'\tmatch: "new UDim2($scaleX, 0, $scaleY, 0)",',
		'\treplacement: "UDim2.fromScale($scaleX, $scaleY)",',
		"});",
	].join("\n")}
	lang="typescript"
	key="pattern-3efmzk"
/>

### Vector2/Vector3

<Code
	code={[
		"pattern({",
		'\tmatch: "new Vector2($x, $x)",',
		'\treplacement: "fromUniform($x)",',
		'\twhen: { x: "!= 0" },',
		"});",
		"",
		"pattern({",
		'\tmatch: "new Vector2($x, 0?)",',
		'\treplacement: "fromX($x)",',
		"});",
		"",
		"pattern({",
		'\tmatch: "new Vector2(0?, $y)",',
		'\treplacement: "fromY($y)",',
		"});",
	].join("\n")}
	lang="typescript"
	key="pattern-gxihrp"
/>

### Color3

<Code
	code={[
		"pattern({",
		'\tmatch: "new Color3(1, 1, 1)",',
		'\treplacement: "Color3.white",',
		"});",
		"",
		"pattern({",
		'\tmatch: "new Color3(0, 0, 0)",',
		'\treplacement: "Color3.black",',
		"});",
	].join("\n")}
	lang="typescript"
	key="pattern-20dnea"
/>

## When Not To Use It

If your codebase doesn't use patterns that have simpler alternatives, or if the verbose syntax is preferred for clarity, you can disable this rule or configure it with specific patterns.

## Related Rules

- [no-color3-constructor](/rules/no-color3-constructor/) - Bans Color3 constructor in favor of fromRGB
- [prefer-udim2-shorthand](/rules/prefer-udim2-shorthand/) - Simplifies UDim2 constructors

## Further Reading

- [roblox-ts Best Practices](https://roblox-ts.com/)
- [Pattern Matching in Programming](https://en.wikipedia.org/wiki/Pattern_matching)
