---
title: no-memo-children
badge:
    text: Best Practice
    variant: success
description: Disallow React.memo on components that accept children (usually useless).
---

import { Aside, Code, LinkCard, CardGrid, Card, Tabs, TabItem, Badge, Steps } from "@astrojs/starlight/components";

Don't `memo` components that accept `children`.

## Rule Details :badge[Best Practice]{variant=success}

`React.memo` does a shallow prop comparison to decide whether to rerender. If a component accepts `children`, that prop
is usually a new JSX element created on every parent render. The comparison fails, so `memo` buys you overhead and
nothing else.

<Aside type="danger" title="The Memo Trap">
	Wrapping a component with `children` in `memo` adds overhead for almost no benefit, because the `children` reference
	changes every time the parent rerenders.
</Aside>

## Refactoring Workflow

<Steps>
1. **Identify Useless Memo**
   Locate components wrapped in `memo` that also destructure `children` from their props.

2. **Remove the Wrapper** Delete the `memo(...)` call. In most cases, performance is identical or slightly better.

3. **Switch to Render Props** If you truly need to skip re-renders, pass a stable function via a `renderContent` prop
   instead of using `children`.

4. **Name Stability** Ensure any components you extract are named correctly so they continue to look good in DevTools
   without the `Memo()` wrapper.

{/* oxfmt-ignore */}

</Steps>

## Examples

<Tabs>
	<TabItem label="❌ Incorrect" icon="close">
		### Memo with Children
		Bans `memo` on components that inherit or define a `children` prop.

    	<Code
    		code={[
    			"// ❌ Card accepts children, so memo will always fail",
    			"const Card = memo<CardProps>(({ title, children }) => {",
    			"\treturn <frame>{children}</frame>;",
    			"});",
    			"",
    			"// ❌ PropsWithChildren also triggers this rule",
    			"const Panel = memo<PropsWithChildren<Props>>(({ children }) => {",
    			"\treturn <frame>{children}</frame>;",
    			"});",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>
    <TabItem label="✅ Correct" icon="check">
    	### Better Optimization
    	Use `memo` only on "leaf" components or use stable render props.

    	<Code
    		code={[
    			"// ✅ OK: Props without children",
    			"const Button = memo(({ label }) => {",
    			"\treturn <textbutton Text={label} />;",
    			"});",
    			"",
    			"// ✅ OK: Render prop pattern",
    			"const List = memo(({ renderItem }) => {",
    			"\treturn <frame>{items.map(renderItem)}</frame>;",
    			"});",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>

</Tabs>

## Why is this bad?

<CardGrid stagger>
	<Card title="Always Unequal" icon="bolt">
		`<span>Text</span>` in JSX is a new object every render. `prev.children !== next.children` is always true.
	</Card>
	<Card title="CPU Waste" icon="list-format">
		The engine compares every primitive prop only to fail at the very end when it checks `children`.
	</Card>
	<Card title="False Security" icon="rocket">
		Developers see `memo` and assume the component is optimized, hiding the real source of lag.
	</Card>
</CardGrid>

## Related Rules

<CardGrid>
	<LinkCard
		title="require-react-display-names"
		description="Ensures components have names in DevTools"
		href="/eslint-cease-nonsense-rules/rules/require-react-display-names/"
	/>
	<LinkCard
		title="ban-react-fc"
		description="Bans problematic React.FC pattern"
		href="/eslint-cease-nonsense-rules/rules/ban-react-fc/"
	/>
</CardGrid>

## Further Reading

<CardGrid>
	<LinkCard
		title="React Docs: memo"
		description="Official guide on component memoization"
		href="https://react.dev/reference/react/memo"
	/>
</CardGrid>
