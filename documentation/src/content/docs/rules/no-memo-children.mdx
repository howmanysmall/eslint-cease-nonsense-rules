---
title: no-memo-children
---

Disallow `React.memo` on components that accept a `children` prop, since children typically change on every render and defeat memoization.

## Rule Details

`React.memo` performs a shallow comparison of props to determine if re-rendering can be skipped. However, when a component accepts `children`, the `children` prop is typically a new JSX element created on every parent render. This causes the shallow comparison to fail every time, making the `memo` wrapper completely ineffective while adding unnecessary overhead.

This rule detects `children` props through:

- Direct `children` property on props interface
- Interfaces extending types with `children` (e.g., `extends PropsWithChildren`)
- Type intersections containing `children` (e.g., `BaseProps & { children?: ReactNode }`)
- Multi-level inheritance chains
- Generic types with `children`
- Union types where any branch has `children`

## Examples

### ❌ Incorrect

**Direct children property**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface CardProps {
	readonly title: string;
	readonly children?: ReactNode;
}

// Error: memo is useless because children change every render
const Card = memo<CardProps>(({ title, children }) => {
	return (
		<frame>
			<textlabel Text={title} />
			{children}
		</frame>
	);
});
```

**Extending PropsWithChildren**

```typescript
import { memo, PropsWithChildren } from "@rbxts/react";

interface PanelProps {
	readonly size: UDim2;
}

// Error: PropsWithChildren adds a children prop
const Panel = memo<PropsWithChildren<PanelProps>>(({ size, children }) => {
	return <frame Size={size}>{children}</frame>;
});
```

**Intersection with children**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface BaseProps {
	readonly id: string;
}

interface WithChildren {
	readonly children?: ReactNode;
}

// Error: Intersection includes children
const Container = memo<BaseProps & WithChildren>(({ id, children }) => {
	return <frame key={id}>{children}</frame>;
});
```

**Multi-level inheritance**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface BaseWithChildren {
	readonly children?: ReactNode;
}

interface LayoutProps extends BaseWithChildren {
	readonly direction: "horizontal" | "vertical";
}

interface FlexProps extends LayoutProps {
	readonly gap: number;
}

// Error: FlexProps inherits children from BaseWithChildren
const FlexContainer = memo<FlexProps>(({ direction, gap, children }) => {
	return <frame>{children}</frame>;
});
```

**Component reference with children**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface WrapperProps {
	readonly padding: number;
	readonly children?: ReactNode;
}

function WrapperNoMemo({ padding, children }: WrapperProps) {
	return <frame Padding={padding}>{children}</frame>;
}

// Error: WrapperNoMemo's props include children
const Wrapper = memo(WrapperNoMemo);
```

### ✅ Correct

**Props without children**

```typescript
import { memo } from "@rbxts/react";

interface ButtonProps {
	readonly label: string;
	readonly onClick: () => void;
}

// OK: No children prop
const Button = memo<ButtonProps>(({ label, onClick }) => {
	return <textbutton Text={label} Event={{ Activated: onClick }} />;
});
```

**Render prop pattern instead of children**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface ListProps<T> {
	readonly items: ReadonlyArray<T>;
	readonly renderItem: (item: T) => ReactNode;
}

// OK: Uses render prop instead of children
const List = memo(<T,>({ items, renderItem }: ListProps<T>) => {
	return <frame>{items.map(renderItem)}</frame>;
});
```

**Content prop instead of children**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface TooltipProps {
	readonly content: ReactNode;
	readonly position: Vector2;
}

// OK: 'content' is a named prop, not 'children'
const Tooltip = memo<TooltipProps>(({ content, position }) => {
	return <frame Position={UDim2.fromOffset(position.X, position.Y)}>{content}</frame>;
});
```

**Allowed via configuration**

```typescript
import { memo, ReactNode } from "@rbxts/react";

interface ModalProps {
	readonly isOpen: boolean;
	readonly children?: ReactNode;
}

// OK: Explicitly allowed in configuration
const Modal = memo<ModalProps>(({ isOpen, children }) => {
	if (!isOpen) return null;
	return <frame>{children}</frame>;
});
```

## Options

### `allowedComponents`

- Type: `string[]`
- Default: `[]`

Component names to allow with children despite the memo wrapper. Use this for components where you've verified memoization is still beneficial (e.g., when children are stable or the comparison function handles children specially).

```jsonc
{
	"cease-nonsense/no-memo-children": [
		"error",
		{
			"allowedComponents": ["Modal", "Drawer", "SpecialContainer"],
		},
	],
}
```

### `environment`

- Type: `"roblox-ts" | "standard"`
- Default: `"roblox-ts"`

Controls which React package sources are checked.

- `"roblox-ts"`: Checks imports from `@rbxts/react` and `@rbxts/roact`
- `"standard"`: Checks imports from `react` and `react-dom`

```jsonc
{
	"cease-nonsense/no-memo-children": [
		"error",
		{
			"environment": "standard",
		},
	],
}
```

## Why Is This Bad?

### Shallow Comparison Always Fails

```typescript
// Parent component
function App() {
	return (
		<Card title="Hello">
			<span>World</span> {/* New object every render! */}
		</Card>
	);
}

// Even though title="Hello" is stable, children is always a new object
// memo's shallow comparison: prevProps.children !== nextProps.children
// Result: Card re-renders every time anyway
```

### Adds Overhead Without Benefit

`memo` adds:

1. Prop comparison on every render
2. Additional wrapper component
3. Memory for storing previous props

When comparison always fails, you pay these costs for zero benefit.

### False Sense of Optimization

Developers may believe their component is optimized when it isn't, leading to performance issues that are hard to diagnose.

## Alternatives

### Render Props

Instead of children, use a render function:

```typescript
interface ListProps<T> {
	readonly items: ReadonlyArray<T>;
	readonly renderItem: (item: T) => ReactNode;
}

const List = memo(({ items, renderItem }: ListProps<string>) => {
	return <frame>{items.map(renderItem)}</frame>;
});

// Usage - renderItem can be stable with useCallback
function App() {
	const renderItem = useCallback((item: string) => <textlabel key={item} Text={item} />, []);
	return <List items={items} renderItem={renderItem} />;
}
```

### Named Content Props

Use explicitly named props instead of children:

```typescript
interface CardProps {
	readonly header: ReactNode;
	readonly body: ReactNode;
}

// Parent can memoize header and body separately if needed
const Card = memo<CardProps>(({ header, body }) => (
	<frame>
		{header}
		{body}
	</frame>
));
```

### Custom Comparison Function

If you must use children, provide a custom comparison:

```typescript
const Card = memo<CardProps>(
	({ title, children }) => <frame>{children}</frame>,
	(prevProps, nextProps) => {
		// Only compare non-children props
		return prevProps.title === nextProps.title;
	},
);
```

Note: This approach is fragile and often not worth the complexity.

## When Not To Use It

- Components where children are guaranteed to be stable (very rare)
- When using a custom comparison function that ignores children
- Legacy code where changing is too risky

## Related Rules

- [require-react-display-names](./require-react-display-names.md) - Ensures memo components have displayName
- [ban-react-fc](./ban-react-fc.md) - Bans problematic React.FC pattern
