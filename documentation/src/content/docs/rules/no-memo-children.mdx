---
title: no-memo-children
---

import { Code } from "@astrojs/starlight/components";

Disallow `React.memo` on components that accept a `children` prop, since children typically change on every render and defeat memoization.

## Rule Details

`React.memo` performs a shallow comparison of props to determine if re-rendering can be skipped. However, when a component accepts `children`, the `children` prop is typically a new JSX element created on every parent render. This causes the shallow comparison to fail every time, making the `memo` wrapper completely ineffective while adding unnecessary overhead.

This rule detects `children` props through:

- Direct `children` property on props interface
- Interfaces extending types with `children` (e.g., `extends PropsWithChildren`)
- Type intersections containing `children` (e.g., `BaseProps & { children?: ReactNode }`)
- Multi-level inheritance chains
- Generic types with `children`
- Union types where any branch has `children`

## Examples

### ❌ Incorrect

**Direct children property**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface CardProps {",
		"\treadonly title: string;",
		"\treadonly children?: ReactNode;",
		"}",
		"",
		"// Error: memo is useless because children change every render",
		"const Card = memo<CardProps>(({ title, children }) => {",
		"\treturn (",
		"\t\t<frame>",
		"\t\t\t<textlabel Text={title} />",
		"\t\t\t{children}",
		"\t\t</frame>",
		"\t);",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-dg8ejq"
/>

**Extending PropsWithChildren**

<Code
	code={[
		'import { memo, PropsWithChildren } from "@rbxts/react";',
		"",
		"interface PanelProps {",
		"\treadonly size: UDim2;",
		"}",
		"",
		"// Error: PropsWithChildren adds a children prop",
		"const Panel = memo<PropsWithChildren<PanelProps>>(({ size, children }) => {",
		"\treturn <frame Size={size}>{children}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-propswit-24k03v"
/>

**Intersection with children**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface BaseProps {",
		"\treadonly id: string;",
		"}",
		"",
		"interface WithChildren {",
		"\treadonly children?: ReactNode;",
		"}",
		"",
		"// Error: Intersection includes children",
		"const Container = memo<BaseProps & WithChildren>(({ id, children }) => {",
		"\treturn <frame key={id}>{children}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-27p4jm"
/>

**Multi-level inheritance**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface BaseWithChildren {",
		"\treadonly children?: ReactNode;",
		"}",
		"",
		"interface LayoutProps extends BaseWithChildren {",
		'\treadonly direction: "horizontal" | "vertical";',
		"}",
		"",
		"interface FlexProps extends LayoutProps {",
		"\treadonly gap: number;",
		"}",
		"",
		"// Error: FlexProps inherits children from BaseWithChildren",
		"const FlexContainer = memo<FlexProps>(({ direction, gap, children }) => {",
		"\treturn <frame>{children}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-253squ"
/>

**Component reference with children**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface WrapperProps {",
		"\treadonly padding: number;",
		"\treadonly children?: ReactNode;",
		"}",
		"",
		"function WrapperNoMemo({ padding, children }: WrapperProps) {",
		"\treturn <frame Padding={padding}>{children}</frame>;",
		"}",
		"",
		"// Error: WrapperNoMemo's props include children",
		"const Wrapper = memo(WrapperNoMemo);",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-2zhi8g"
/>

### ✅ Correct

**Props without children**

<Code
	code={[
		'import { memo } from "@rbxts/react";',
		"",
		"interface ButtonProps {",
		"\treadonly label: string;",
		"\treadonly onClick: () => void;",
		"}",
		"",
		"// OK: No children prop",
		"const Button = memo<ButtonProps>(({ label, onClick }) => {",
		"\treturn <textbutton Text={label} Event={{ Activated: onClick }} />;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-from-rbx-1i6v0b"
/>

**Render prop pattern instead of children**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface ListProps<T> {",
		"\treadonly items: ReadonlyArray<T>;",
		"\treadonly renderItem: (item: T) => ReactNode;",
		"}",
		"",
		"// OK: Uses render prop instead of children",
		"const List = memo(<T,>({ items, renderItem }: ListProps<T>) => {",
		"\treturn <frame>{items.map(renderItem)}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-3o0w0b"
/>

**Content prop instead of children**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface TooltipProps {",
		"\treadonly content: ReactNode;",
		"\treadonly position: Vector2;",
		"}",
		"",
		"// OK: 'content' is a named prop, not 'children'",
		"const Tooltip = memo<TooltipProps>(({ content, position }) => {",
		"\treturn <frame Position={UDim2.fromOffset(position.X, position.Y)}>{content}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-2milwv"
/>

**Allowed via configuration**

<Code
	code={[
		'import { memo, ReactNode } from "@rbxts/react";',
		"",
		"interface ModalProps {",
		"\treadonly isOpen: boolean;",
		"\treadonly children?: ReactNode;",
		"}",
		"",
		"// OK: Explicitly allowed in configuration",
		"const Modal = memo<ModalProps>(({ isOpen, children }) => {",
		"\tif (!isOpen) return null;",
		"\treturn <frame>{children}</frame>;",
		"});",
	].join("\n")}
	lang="typescript"
	key="import-memo-reactnod-17m3lz"
/>

## Options

### `allowedComponents`

- Type: `string[]`
- Default: `[]`

Component names to allow with children despite the memo wrapper. Use this for components where you've verified memoization is still beneficial (e.g., when children are stable or the comparison function handles children specially).

<Code
	code={[
		"{",
		'\t"cease-nonsense/no-memo-children": [',
		'\t\t"error",',
		"\t\t{",
		'\t\t\t"allowedComponents": ["Modal", "Drawer", "SpecialContainer"],',
		"\t\t},",
		"\t],",
		"}",
	].join("\n")}
	lang="typescript"
	key="block-9-5g24mg"
/>

### `environment`

- Type: `"roblox-ts" | "standard"`
- Default: `"roblox-ts"`

Controls which React package sources are checked.

- `"roblox-ts"`: Checks imports from `@rbxts/react` and `@rbxts/roact`
- `"standard"`: Checks imports from `react` and `react-dom`

<Code
	code={[
		"{",
		'\t"cease-nonsense/no-memo-children": [',
		'\t\t"error",',
		"\t\t{",
		'\t\t\t"environment": "standard",',
		"\t\t},",
		"\t],",
		"}",
	].join("\n")}
	lang="typescript"
	key="block-10-zlngbi"
/>

## Why Is This Bad?

### Shallow Comparison Always Fails

<Code
	code={[
		"// Parent component",
		"function App() {",
		"\treturn (",
		'\t\t<Card title="Hello">',
		"\t\t\t<span>World</span> {/* New object every render! */}",
		"\t\t</Card>",
		"\t);",
		"}",
		"",
		'// Even though title="Hello" is stable, children is always a new object',
		"// memo's shallow comparison: prevProps.children !== nextProps.children",
		"// Result: Card re-renders every time anyway",
	].join("\n")}
	lang="typescript"
	key="parent-component-2zqus8"
/>

### Adds Overhead Without Benefit

`memo` adds:

1. Prop comparison on every render
2. Additional wrapper component
3. Memory for storing previous props

When comparison always fails, you pay these costs for zero benefit.

### False Sense of Optimization

Developers may believe their component is optimized when it isn't, leading to performance issues that are hard to diagnose.

## Alternatives

### Render Props

Instead of children, use a render function:

<Code
	code={[
		"interface ListProps<T> {",
		"\treadonly items: ReadonlyArray<T>;",
		"\treadonly renderItem: (item: T) => ReactNode;",
		"}",
		"",
		"const List = memo(({ items, renderItem }: ListProps<string>) => {",
		"\treturn <frame>{items.map(renderItem)}</frame>;",
		"});",
		"",
		"// Usage - renderItem can be stable with useCallback",
		"function App() {",
		"\tconst renderItem = useCallback((item: string) => <textlabel key={item} Text={item} />, []);",
		"\treturn <List items={items} renderItem={renderItem} />;",
		"}",
	].join("\n")}
	lang="typescript"
	key="interface-listprops--wd7hko"
/>

### Named Content Props

Use explicitly named props instead of children:

<Code
	code={[
		"interface CardProps {",
		"\treadonly header: ReactNode;",
		"\treadonly body: ReactNode;",
		"}",
		"",
		"// Parent can memoize header and body separately if needed",
		"const Card = memo<CardProps>(({ header, body }) => (",
		"\t<frame>",
		"\t\t{header}",
		"\t\t{body}",
		"\t</frame>",
		"));",
	].join("\n")}
	lang="typescript"
	key="interface-cardprops-1jiyg7"
/>

### Custom Comparison Function

If you must use children, provide a custom comparison:

<Code
	code={[
		"const Card = memo<CardProps>(",
		"\t({ title, children }) => <frame>{children}</frame>,",
		"\t(prevProps, nextProps) => {",
		"\t\t// Only compare non-children props",
		"\t\treturn prevProps.title === nextProps.title;",
		"\t},",
		");",
	].join("\n")}
	lang="typescript"
	key="const-card-memo-card-1ws15i"
/>

Note: This approach is fragile and often not worth the complexity.

## When Not To Use It

- Components where children are guaranteed to be stable (very rare)
- When using a custom comparison function that ignores children
- Legacy code where changing is too risky

## Related Rules

- [require-react-display-names](./require-react-display-names.md) - Ensures memo components have displayName
- [ban-react-fc](./ban-react-fc.md) - Bans problematic React.FC pattern
