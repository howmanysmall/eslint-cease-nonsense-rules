---
title: react-hooks-strict-return
---

React hooks must return a tuple of ≤2 elements or a single object. Prevents unwieldy hook return types.

## Rule Details

Custom React hooks should return either:

- A tuple with at most 2 elements (like `useState`)
- A single object
- A single non-array value

Returning tuples with 3+ elements makes destructuring awkward and unclear.

## Examples

### ❌ Incorrect

```typescript
function useMyHook() {
	return [a, b, c]; // 3 elements
}

function useData() {
	return [state, setState, loading, error]; // 4 elements
}

function useComplexState() {
	const items = [1, 2, 3, 4, 5];
	return items; // Variable reference to 5-element array
}

// Even with type annotations
function useBadHook(): [string, number, boolean, object] {
	return ["", 0, false, {}];
}
```

### ✅ Correct

```typescript
// Standard 2-element tuple (like useState)
function useMyHook() {
	return [state, setState];
}

// Single object with named properties
function useData() {
	return { state, setState, loading, error };
}

// Single value
function useCurrentUser() {
	return user;
}

// Objects are fine regardless of size
function useComplexData() {
	return {
		a,
		b,
		c,
		d,
		e,
		f,
	}; // 6 properties OK
}

// Array of data (not a return tuple)
function useItems() {
	return items; // OK if used as data, not destructured
}
```

## Why Limit Tuple Size?

### Readability

Destructuring 3+ elements is hard to read and maintain:

```typescript
// Unclear: what are these values?
const [a, b, c, d] = useComplexHook();

// Clear: named properties
const { state, loading, error, refetch } = useComplexHook();
```

### Positional Confusion

With many positional values, it's easy to swap them:

```typescript
// Which is which?
const [data, error, loading, refetch] = useFetch();
const [data, loading, error, refetch] = useFetch(); // Bug!

// Named properties prevent confusion
const { data, error, loading, refetch } = useFetch();
```

### Optional Returns

Objects handle optional returns gracefully:

```typescript
// Awkward: have to track position of undefined
const [data, , error] = useData(); // Skipping loading

// Natural: only destructure what you need
const { data, error } = useData(); // loading not needed
```

## React Hook Patterns

### State Hooks (2-element tuple)

```typescript
function useToggle(initial = false): [boolean, () => void] {
	const [value, setValue] = useState(initial);
	const toggle = () => setValue((v) => !v);
	return [value, toggle];
}

// Usage
const [isOpen, toggle] = useToggle();
```

### Data Hooks (object)

```typescript
interface UseDataResult<T> {
	data: T | undefined;
	loading: boolean;
	error: Error | undefined;
	refetch: () => void;
}

function useData<T>(url: string): UseDataResult<T> {
	// ...
	return { data, loading, error, refetch };
}

// Usage
const { data, loading } = useData<User>("/api/user");
```

### Value Hooks (single value)

```typescript
function useWindowWidth(): number {
	const [width, setWidth] = useState(window.innerWidth);
	// ...
	return width;
}

// Usage
const width = useWindowWidth();
```

## Migration Guide

### Before (3+ Element Tuple)

```typescript
function useForm() {
	const [values, setValues] = useState({});
	const [errors, setErrors] = useState({});
	const [touched, setTouched] = useState({});

	return [values, setValues, errors, setErrors, touched, setTouched];
}

// Usage
const [values, setValues, errors, setErrors, touched, setTouched] = useForm();
```

### After (Object Return)

```typescript
interface UseFormReturn {
	values: Record<string, unknown>;
	setValues: (v: Record<string, unknown>) => void;
	errors: Record<string, string>;
	setErrors: (e: Record<string, string>) => void;
	touched: Record<string, boolean>;
	setTouched: (t: Record<string, boolean>) => void;
}

function useForm(): UseFormReturn {
	const [values, setValues] = useState({});
	const [errors, setErrors] = useState({});
	const [touched, setTouched] = useState({});

	return { values, setValues, errors, setErrors, touched, setTouched };
}

// Usage (more flexible)
const { values, errors } = useForm(); // Only what you need
const form = useForm(); // Or use the whole object
```

## Edge Cases

### Non-Hook Functions

This rule only applies to functions starting with `use`:

```typescript
// Not affected (not a hook)
function getData() {
	return [1, 2, 3, 4, 5]; // OK
}

// Affected (is a hook)
function useData() {
	return [1, 2, 3, 4, 5]; // Error
}
```

### Type-Only Arrays

If a hook returns an array of data (not a tuple), it should be typed accordingly:

```typescript
// Wrong: tuple type suggests positional destructuring
function useItems(): [Item, Item, Item, Item] {
	return [item1, item2, item3, item4];
}

// Right: array type suggests it's data
function useItems(): Item[] {
	return [item1, item2, item3, item4];
}
```

## When Not To Use It

If you have a specific reason to return 3+ element tuples (extremely rare), you can disable this rule. However, consider refactoring to an object return instead.

## Related Rules

- [react-hooks-strict-return](/rules/react-hooks-strict-return/) - This rule

## Further Reading

- [React Hooks API Reference](https://react.dev/reference/react/hooks)
- [Custom Hook Patterns](https://react.dev/learn/reusing-logic-with-custom-hooks)
