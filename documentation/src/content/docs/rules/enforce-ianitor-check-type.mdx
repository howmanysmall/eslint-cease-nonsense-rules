---
title: enforce-ianitor-check-type
---

Enforces `Ianitor.Check<T>` type annotations on complex TypeScript types to ensure runtime validation.

## Rule Details

This rule calculates structural complexity of TypeScript types and requires Ianitor validators when complexity exceeds configured thresholds. Runtime validation prevents type mismatches that TypeScript cannot catch at compile time.

## Options

```jsonc
{
	"cease-nonsense/enforce-ianitor-check-type": [
		"error",
		{
			"baseThreshold": 10, // Minimum complexity to require validation
			"warnThreshold": 15, // Warning threshold
			"errorThreshold": 25, // Error threshold
			"interfacePenalty": 20, // Complexity penalty for interfaces
			"performanceMode": true, // Enable performance optimizations
		},
	],
}
```

### Configuration Parameters

- **baseThreshold** (default: `10`): Minimum structural complexity score to trigger validation requirement
- **warnThreshold** (default: `15`): Complexity level that produces warnings
- **errorThreshold** (default: `25`): Complexity level that produces errors
- **interfacePenalty** (default: `20`): Additional complexity added for interface types
- **performanceMode** (default: `true`): Enable caching and optimization for large codebases

## Examples

### ❌ Incorrect

```typescript
// Complex type without runtime validation
type UserConfig = {
	id: number;
	name: string;
	settings: {
		theme: string;
		notifications: boolean;
	};
};

const config = getUserConfig(); // No runtime check!

// Deeply nested type without validation
type ApiResponse = {
	data: {
		users: Array<{
			id: number;
			profile: {
				avatar: string;
				bio: string;
			};
		}>;
	};
	meta: {
		page: number;
		total: number;
	};
};
```

### ✅ Correct

```typescript
const userConfigValidator = Ianitor.interface({
	id: Ianitor.number(),
	name: Ianitor.string(),
	settings: Ianitor.interface({
		theme: Ianitor.string(),
		notifications: Ianitor.boolean(),
	}),
});

type UserConfig = Ianitor.Static<typeof userConfigValidator>;

const config = userConfigValidator.check(getUserConfig());

// With nested validators
const apiResponseValidator = Ianitor.interface({
	data: Ianitor.interface({
		users: Ianitor.array(
			Ianitor.interface({
				id: Ianitor.number(),
				profile: Ianitor.interface({
					avatar: Ianitor.string(),
					bio: Ianitor.string(),
				}),
			}),
		),
	}),
	meta: Ianitor.interface({
		page: Ianitor.number(),
		total: Ianitor.number(),
	}),
});

type ApiResponse = Ianitor.Static<typeof apiResponseValidator>;
```

## When Not To Use It

If you're working in a fully type-safe environment with no external data sources or runtime type validation requirements, this rule may be overly restrictive.

## Complexity Calculation

The rule calculates complexity by:

1. Counting nested object properties
2. Weighing array types and unions
3. Adding penalties for interface types
4. Accumulating complexity scores across type hierarchies

Types exceeding the configured thresholds require Ianitor validation.

## Further Reading

- [Ianitor Documentation](https://github.com/howmanysmall/ianitor)
- [Runtime Type Validation Best Practices](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
