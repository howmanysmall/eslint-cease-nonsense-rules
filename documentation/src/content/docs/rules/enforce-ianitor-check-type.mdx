---
title: enforce-ianitor-check-type
---

import { Code } from "@astrojs/starlight/components";

Enforces `Ianitor.Check<T>` type annotations on complex TypeScript types to ensure runtime validation.

## Rule Details

This rule calculates structural complexity of TypeScript types and requires Ianitor validators when complexity exceeds configured thresholds. Runtime validation prevents type mismatches that TypeScript cannot catch at compile time.

## Options

<Code
	code={[
		"{",
		'\t"cease-nonsense/enforce-ianitor-check-type": [',
		'\t\t"error",',
		"\t\t{",
		'\t\t\t"baseThreshold": 10, // Minimum complexity to require validation',
		'\t\t\t"warnThreshold": 15, // Warning threshold',
		'\t\t\t"errorThreshold": 25, // Error threshold',
		'\t\t\t"interfacePenalty": 20, // Complexity penalty for interfaces',
		'\t\t\t"performanceMode": true, // Enable performance optimizations',
		"\t\t},",
		"\t],",
		"}",
	].join("\n")}
	lang="typescript"
	key="block-0-3izarl"
/>

### Configuration Parameters

- **baseThreshold** (default: `10`): Minimum structural complexity score to trigger validation requirement
- **warnThreshold** (default: `15`): Complexity level that produces warnings
- **errorThreshold** (default: `25`): Complexity level that produces errors
- **interfacePenalty** (default: `20`): Additional complexity added for interface types
- **performanceMode** (default: `true`): Enable caching and optimization for large codebases

## Examples

### ❌ Incorrect

<Code
	code={[
		"// Complex type without runtime validation",
		"type UserConfig = {",
		"\tid: number;",
		"\tname: string;",
		"\tsettings: {",
		"\t\ttheme: string;",
		"\t\tnotifications: boolean;",
		"\t};",
		"};",
		"",
		"const config = getUserConfig(); // No runtime check!",
		"",
		"// Deeply nested type without validation",
		"type ApiResponse = {",
		"\tdata: {",
		"\t\tusers: Array<{",
		"\t\t\tid: number;",
		"\t\t\tprofile: {",
		"\t\t\t\tavatar: string;",
		"\t\t\t\tbio: string;",
		"\t\t\t};",
		"\t\t}>;",
		"\t};",
		"\tmeta: {",
		"\t\tpage: number;",
		"\t\ttotal: number;",
		"\t};",
		"};",
	].join("\n")}
	lang="typescript"
	key="complex-type-without-23wxll"
/>

### ✅ Correct

<Code
	code={[
		"const userConfigValidator = Ianitor.interface({",
		"\tid: Ianitor.number(),",
		"\tname: Ianitor.string(),",
		"\tsettings: Ianitor.interface({",
		"\t\ttheme: Ianitor.string(),",
		"\t\tnotifications: Ianitor.boolean(),",
		"\t}),",
		"});",
		"",
		"type UserConfig = Ianitor.Static<typeof userConfigValidator>;",
		"",
		"const config = userConfigValidator.check(getUserConfig());",
		"",
		"// With nested validators",
		"const apiResponseValidator = Ianitor.interface({",
		"\tdata: Ianitor.interface({",
		"\t\tusers: Ianitor.array(",
		"\t\t\tIanitor.interface({",
		"\t\t\t\tid: Ianitor.number(),",
		"\t\t\t\tprofile: Ianitor.interface({",
		"\t\t\t\t\tavatar: Ianitor.string(),",
		"\t\t\t\t\tbio: Ianitor.string(),",
		"\t\t\t\t}),",
		"\t\t\t}),",
		"\t\t),",
		"\t}),",
		"\tmeta: Ianitor.interface({",
		"\t\tpage: Ianitor.number(),",
		"\t\ttotal: Ianitor.number(),",
		"\t}),",
		"});",
		"",
		"type ApiResponse = Ianitor.Static<typeof apiResponseValidator>;",
	].join("\n")}
	lang="typescript"
	key="const-userconfigvali-21wm5w"
/>

## When Not To Use It

If you're working in a fully type-safe environment with no external data sources or runtime type validation requirements, this rule may be overly restrictive.

## Complexity Calculation

The rule calculates complexity by:

1. Counting nested object properties
2. Weighing array types and unions
3. Adding penalties for interface types
4. Accumulating complexity scores across type hierarchies

Types exceeding the configured thresholds require Ianitor validation.

## Further Reading

- [Ianitor Documentation](https://github.com/howmanysmall/ianitor)
- [Runtime Type Validation Best Practices](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
