---
title: enforce-ianitor-check-type
badge:
    text: Roblox
    variant: note
description: Enforces Ianitor.Check<T> type annotations on complex TypeScript types to ensure runtime validation.
---

import { Aside, Code, LinkCard, CardGrid, Card, Tabs, TabItem, Badge, Steps } from "@astrojs/starlight/components";

Enforces `Ianitor.Check<T>` type annotations on complex types.

## Rule Details :badge[Roblox]{variant=note}

This rule calculates the structural complexity of your TypeScript types and requires `Ianitor` validators when
complexity exceeds configured thresholds. Runtime validation prevents "impossible" states and type mismatches that
TypeScript cannot catch at compile time—critical for data from DataStores or RemoteEvents.

<Aside type="caution" title="Runtime Safety">
	TypeScript only provides compile-time safety. `Ianitor` ensures that data coming from external sources (like
	DataStores) actually matches your expected shapes.
</Aside>

## Validation Workflow

<Steps>
1. **Analyze Type Shape**
   The linter recursively calculates a complexity score based on nesting, property counts, and structural weight.
2. **Trigger Threshold** If the score exceeds the configured limit, a linter error will prompt you for a runtime check.
3. **Define Ianitor Schema** Create an `Ianitor` validator that matches your TypeScript interface.
4. **Derive Type** Use `type MyType = Ianitor.Static<typeof myValidator>` to ensure your runtime check and type are
   perfectly synced.
{/* oxfmt-ignore */}

</Steps>

## Examples

<Tabs>
	<TabItem label="❌ Incorrect" icon="close">
		### Dangerous Types
		Bans complex, deeply nested types that lack a runtime validation schema.

    	<Code
    		code={[
    			"// Too complex to be trusted without a check!",
    			"type UserPayload = {",
    			"\tdata: {",
    			"\t\tpreferences: {",
    			"\t\t\ttheme: string;",
    			"\t\t\tblurEnabled: boolean;",
    			"\t\t};",
    			"\t\tlastLogin: number;",
    			"\t};",
    			"};",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>
    <TabItem label="✅ Correct" icon="check">
    	### Schema-Derived Types
    	Define the schema once and use `Ianitor.Static` to get the TypeScript type.

    	<Code
    		code={[
    			"const userValidator = Ianitor.interface({",
    			"\tdata: Ianitor.interface({",
    			"\t\tpreferences: Ianitor.interface({ ... }),",
    			"\t\tlastLogin: Ianitor.number(),",
    			"\t}),",
    			"});",
    			"",
    			"// Safely derived and validated",
    			"type UserPayload = Ianitor.Static<typeof userValidator>;",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>

</Tabs>

## Complexity Factors

<CardGrid stagger>
	<Card title="Structural Weight" icon="list-format">
		Unions, intersections, and optional properties add more complexity than simple primitives.
	</Card>
	<Card title="Nesting Depth" icon="magnifier">
		Each level of object nesting multiplies the complexity score significantly.
	</Card>
	<Card title="Property Density" icon="bolt">
		Large objects with dozens of fields are penalized to encourage modular sub-interfaces.
	</Card>
	<Card title="Performance" icon="setting">
		The rule uses aggressive caching to ensure calculation doesn't slow down your IDE.
	</Card>
</CardGrid>

## Related Rules

<CardGrid>
	<LinkCard
		title="require-serialized-numeric-data-type"
		description="Correct types for binary data"
		href="/eslint-cease-nonsense-rules/rules/require-serialized-numeric-data-type/"
	/>
</CardGrid>

## Further Reading

<CardGrid>
	<LinkCard
		title="Ianitor GitHub"
		description="Official source for the Ianitor library"
		href="https://github.com/howmanysmall/ianitor"
	/>
</CardGrid>
