---
title: prefer-single-world-query
---

Enforces combining multiple `world.get()` or `world.has()` calls on the same entity into a single call for better Jecs performance.

## Rule Details

In Jecs (a Roblox ECS library), calling `world.get()` or `world.has()` multiple times on the same entity results in multiple archetype lookups. Combining these calls into a single call improves performance by reducing lookups and cache misses.

This rule detects consecutive `world.get()` or `world.has()` calls on the same world and entity, and provides an automatic fix to merge them.

## world.get() Examples

### ❌ Incorrect

```typescript
// Multiple lookups - inefficient
const position = world.get(entity, Position);
const velocity = world.get(entity, Velocity);
const health = world.get(entity, Health);
```

### ✅ Correct

```typescript
// Single lookup - efficient
const [position, velocity, health] = world.get(entity, Position, Velocity, Health);
```

## world.has() Examples

### ❌ Incorrect

```typescript
// Multiple lookups - inefficient
const hasPosition = world.has(entity, Position);
const hasVelocity = world.has(entity, Velocity);
if (hasPosition && hasVelocity) {
	// Entity has both components
}
```

### ✅ Correct

```typescript
// Single lookup - efficient
const hasAll = world.has(entity, Position, Velocity);
if (hasAll) {
	// Entity has both components
}
```

### ⚠️ Not Flagged (used separately)

```typescript
// Not flagged - has() calls used independently
const hasPosition = world.has(entity, Position);
const hasVelocity = world.has(entity, Velocity);

// Different control flow
if (hasPosition) updatePosition();
if (hasVelocity) updateVelocity();
```

## Performance Benefits

### Reduced Archetype Lookups

Each `world.get()` or `world.has()` call performs an archetype lookup. Combining calls reduces overhead:

```typescript
// ❌ 3 archetype lookups
const position = world.get(entity, Position);
const velocity = world.get(entity, Velocity);
const health = world.get(entity, Health);

// ✅ 1 archetype lookup
const [position, velocity, health] = world.get(entity, Position, Velocity, Health);
```

### Cache Efficiency

Jecs caches archetype information. Multiple calls on the same entity benefit from cache locality when combined:

```typescript
// ❌ Cache may be invalidated between calls
const transform = world.get(entity, Transform);
// ... other code ...
const model = world.get(entity, Model);

// ✅ Cache remains valid for single lookup
const [transform, model] = world.get(entity, Transform, Model);
```

## Auto-Fix Behavior

This rule provides automatic fixes:

### For world.get()

```typescript
// Before:
const position = world.get(entity, Position);
const velocity = world.get(entity, Velocity);

// After (auto-fixed):
const [position, velocity] = world.get(entity, Position, Velocity);
```

### For world.has()

```typescript
// Before:
const hasA = world.has(entity, ComponentA);
const hasB = world.has(entity, ComponentB);
if (hasA && hasB) { ... }

// After (auto-fixed):
const hasA = world.has(entity, ComponentA, ComponentB);
if (hasA) { ... }
```

Note: `world.has()` calls are only combined when their results are ANDed together (`hasA && hasB`), as this maintains equivalent semantics. If the `has()` results are used separately, they won't be combined.

## Supported Patterns

### Basic Variable Declarations

```typescript
// Detected and fixed
const position = world.get(entity, Position);
const velocity = world.get(entity, Velocity);
```

### Method Chains

```typescript
// Detected when world is a member expression
const position = this.world.get(entity, Position);
const velocity = this.world.get(entity, Velocity);
```

### Complex Entity Expressions

```typescript
// Detected when entity expression matches
const a = world.get(entities[0], ComponentA);
const b = world.get(entities[0], ComponentB);
```

### has() in Control Flow

```typescript
// Detected when has() calls are ANDed
const hasA = world.has(entity, ComponentA);
const hasB = world.has(entity, ComponentB);
while (hasA && hasB) { ... }
```

## Limitations

### Maximum Components

Jecs supports up to 4 components per `get()` or `has()` call. The rule will not combine more than 4 calls on the same entity:

```typescript
// These 5 calls will NOT be combined (exceeds Jecs limit)
const a = world.get(entity, A);
const b = world.get(entity, B);
const c = world.get(entity, C);
const d = world.get(entity, D);
const e = world.get(entity, E);
```

### has() Semantics

`world.has(entity, A, B)` returns `true` only if the entity has **ALL** specified components. This is equivalent to `world.has(entity, A) && world.has(entity, B)`. Therefore, the rule only combines `has()` calls when their results are ANDed together.

```typescript
// ❌ Detected and fixed (ANDed usage)
const hasA = world.has(entity, A);
const hasB = world.has(entity, B);
if (hasA && hasB) { ... }

// ✅ Not detected (separate usage)
const hasA = world.has(entity, A);
const hasB = world.has(entity, B);
if (hasA) doA();
if (hasB) doB();

// ✅ Not detected (OR usage)
const hasA = world.has(entity, A);
const hasB = world.has(entity, B);
if (hasA || hasB) { ... }
```

### Non-Consecutive Calls

Currently, the rule only detects calls within the same program/file scope. Calls separated by unrelated code may not be detected in all cases.

### Non-Identifier Variables

The rule only optimizes simple variable declarations with identifiers:

```typescript
// ❌ Not optimized (destructuring)
const { x } = world.get(entity, ComponentA);
const { y } = world.get(entity, ComponentB);

// ❌ Not optimized (let declaration)
let x = world.get(entity, ComponentA);
let y = world.get(entity, ComponentB);
```

## When Not To Use It

Disable this rule if:

- You intentionally want separate lookups for debugging purposes
- You're using a custom ECS implementation with different semantics
- You prefer explicit single-component lookups for code clarity

## Related Rules

- [prefer-pattern-replacements](/rules/prefer-pattern-replacements/) - Optimizes constructor patterns
- [no-identity-map](/rules/no-identity-map/) - Detects pointless identity operations

## Further Reading

- [Jecs Documentation](https://github.com/ukendio/jecs)
- [ECS Architecture Patterns](https://en.wikipedia.org/wiki/Entity_component_system)
