---
title: require-serialized-numeric-data-type
---

Require specific serialized numeric data types (`DataType.*`) instead of generic `number` for ECS components and other serialization contexts.

## Rule Details

When working with serialization systems like `@rbxts/flamework-binary-serializer`, using the generic `number` type is problematic because the serializer doesn't know which binary representation to use. This rule enforces the use of specific `DataType` variants that explicitly declare the serialization format.

### Supported DataType variants

- `DataType.u8` - Unsigned 8-bit integer (0 to 255)
- `DataType.u16` - Unsigned 16-bit integer (0 to 65,535)
- `DataType.u32` - Unsigned 32-bit integer (0 to 4,294,967,295)
- `DataType.i8` - Signed 8-bit integer (-128 to 127)
- `DataType.i16` - Signed 16-bit integer (-32,768 to 32,767)
- `DataType.i32` - Signed 32-bit integer (-2,147,483,648 to 2,147,483,647)
- `DataType.f32` - 32-bit floating point
- `DataType.f64` - 64-bit floating point (double precision)

## Modes

The rule supports two check modes:

### `type-arguments` (default)

Only checks type arguments of specific function calls (e.g., `registerComponent<T>()`).

### `all`

Checks all `number` type annotations globally, including:

- Variable declarations
- Function parameters and return types
- Interface and type alias properties
- Class properties and method signatures

## Options

```typescript
interface RequireSerializedNumericDataTypeOptions {
	/**
	 * Check mode:
	 * - `"type-arguments"` (default): Only check type arguments of function calls
	 * - `"all"`: Check all `number` type annotations globally
	 */
	mode?: "type-arguments" | "all";

	/**
	 * Function names to check for type arguments when mode is "type-arguments".
	 * @default ["registerComponent"]
	 */
	functionNames?: string[];

	/**
	 * When true, resolves type aliases using TypeScript's type checker.
	 * Slower but catches aliased types like `type Foo = number`.
	 * Requires `parserOptions.project` to be configured.
	 * @default false
	 */
	strict?: boolean;
}
```

### Default Configuration

```jsonc
{
	"cease-nonsense/require-serialized-numeric-data-type": "error",
}
```

### Custom Function Names

```jsonc
{
	"cease-nonsense/require-serialized-numeric-data-type": [
		"error",
		{
			"functionNames": ["registerComponent", "registerEvent", "createReplicatedValue"],
		},
	],
}
```

### Global Mode

```jsonc
{
	"cease-nonsense/require-serialized-numeric-data-type": ["error", { "mode": "all" }],
}
```

### Strict Mode

```jsonc
{
	"cease-nonsense/require-serialized-numeric-data-type": ["error", { "strict": true }],
}
```

## Examples

### Incorrect

```typescript
// Generic number type
export const WaveNumber = registerComponent<number>({ replicated: true });

// Object with number property
export const Timer = registerComponent<{ elapsed: number }>({ replicated: true });

// Union containing number
export const Value = registerComponent<number | string>({ replicated: true });

// Branded number (still serialized as number)
export const BrandedId = registerComponent<number & { _brand: "id" }>({ replicated: true });

// Array of numbers
export const Values = registerComponent<number[]>({ replicated: true });
```

### Correct

```typescript
import type { DataType } from "@rbxts/flamework-binary-serializer";

// Specific DataType variants
export const WaveNumber = registerComponent<DataType.u8>({ replicated: true });
export const Timer = registerComponent<DataType.f32>({ replicated: true });
export const Money = registerComponent<DataType.u32>({ replicated: true });

// Object with DataType properties
export const Position = registerComponent<{
	x: DataType.f32;
	y: DataType.f32;
	z: DataType.f32;
}>({ replicated: true });

// Union of DataTypes (allowed)
export const Value = registerComponent<DataType.u8 | DataType.u32>({ replicated: true });

// Array of DataType
export const Values = registerComponent<DataType.u8[]>({ replicated: true });

// Other types (not number)
export const Name = registerComponent<string>({ replicated: true });
export const Active = registerComponent<boolean>({ replicated: true });
```

### Global Mode Examples

When `mode: "all"` is configured:

**Incorrect:**

```typescript
// Variable declaration
const health: number = 100;

// Function parameter
function calculateDamage(base: number, multiplier: number): number {
	return base * multiplier;
}

// Interface property
interface PlayerStats {
	health: number;
	mana: number;
}

// Type alias
type ScoreValue = number;
```

**Correct:**

```typescript
// Variable declaration
const health: DataType.u16 = 100;

// Function parameter
function calculateDamage(base: DataType.f32, multiplier: DataType.f32): DataType.f32 {
	return base * multiplier;
}

// Interface property
interface PlayerStats {
	health: DataType.u16;
	mana: DataType.u16;
}

// Type alias
type ScoreValue = DataType.u32;
```

## When Not To Use It

If you're not using a serialization system that requires specific numeric type annotations, you can disable this rule. The generic `number` type is perfectly fine for most TypeScript code that doesn't serialize over the network.

## Related Rules

- [`enforce-ianitor-check-type`](./enforce-ianitor-check-type.md) - Enforces runtime type validation for complex types
