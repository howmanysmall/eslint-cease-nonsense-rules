---
title: require-serialized-numeric-data-type
badge:
    text: Roblox
    variant: caution
description:
    Require specific serialized numeric data types (DataType.*) instead of generic number for ECS components and other
    serialization contexts.
---

import { Aside, Code, LinkCard, CardGrid, Card, Tabs, TabItem, Badge, Steps } from "@astrojs/starlight/components";

Require specific numeric data types instead of generic `number`.

## Rule Details :badge[Roblox]{variant=caution}

When working with serialization systems like `@rbxts/flamework-binary-serializer`, the generic `number` type is
ambiguous. The serializer doesn't know whether to use a small integer, a large signed value, or a high-precision double.
This rule enforces the use of explicit `DataType` variants to optimize network bandwidth and memory usage.

<Aside type="tip" title="Network Optimization">
	Using `DataType.u8` instead of `number` can save 7 bytes of bandwidth per value in every replicated packet. In
	high-frequency ECS systems, this difference is massive.
</Aside>

## Choosing a Data Type

<Steps>
1. **Determine Range**
   Check if your value is always positive (`u`) or can be negative (`i`).
2. **Check Magnitude**
   Select the smallest bit-size that fits your maximum value (e.g., `u8` for 0-255, `u16` for up to 65k).
3. **Float vs Integer**
   Use `f32` or `f64` only if you need decimal precision.
4. **Apply to Type**
   Replace `number` in your component interface or function arguments with the specific `DataType`.

{/* oxfmt-ignore */}

</Steps>

## Examples

<Tabs>
	<TabItem label="❌ Incorrect" icon="close">
		### Ambiguous Numbers
		Bans generic `number` in serialization contexts.

    	<Code
    		code={[
    			"// Serializer doesn't know how to pack this",
    			"export const WaveNumber = registerComponent<number>({ replicated: true });",
    			"",
    			"interface Stats {",
    			"\thealth: number;",
    			"}",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>
    <TabItem label="✅ Correct" icon="check">
    	### Explicit Variants
    	Use the `DataType` enum to specify the exact binary format.

    	<Code
    		code={[
    			'import type { DataType } from "@rbxts/flamework-binary-serializer";',
    			"",
    			"// Explicit 8-bit unsigned integer",
    			"export const WaveNumber = registerComponent<DataType.u8>({ replicated: true });",
    			"",
    			"interface Stats {",
    			"\thealth: DataType.u16;",
    			"}",
    		].join("\n")}
    		lang="tsx"
    	/>
    </TabItem>

</Tabs>

## Supported Types

<CardGrid stagger>
	<Card title="Unsigned Ints" icon="approve-check">
		`u8` (0-255), `u16` (0-65k), `u32` (0-4b).
	</Card>
	<Card title="Signed Ints" icon="warning">
		`i8` (-128 to 127), `i16` (-32k to 32k), `i32` (-2b to 2b).
	</Card>
	<Card title="Floats" icon="bolt">
		`f32` (Standard precision), `f64` (Double precision).
	</Card>
</CardGrid>

## Configuration Example

<Code
	code={[
		"{",
		'\t"cease-nonsense/require-serialized-numeric-data-type": [',
		'\t\t"error",',
		"\t\t{",
		'\t\t\t"mode": "type-arguments",',
		'\t\t\t"functionNames": ["registerComponent", "createEvent"]',
		"\t\t}",
		"\t]",
		"}",
	].join("\n")}
	lang="json"
	title="eslint.config.js"
/>

## Related Rules

<CardGrid>
	<LinkCard
		title="enforce-ianitor-check-type"
		description="Runtime type validation"
		href="/eslint-cease-nonsense-rules/rules/enforce-ianitor-check-type/"
	/>
</CardGrid>

## Further Reading

<CardGrid>
	<LinkCard
		title="Flamework Binary Serializer"
		description="Official documentation for binary replication"
		href="https://flamework.cloud/docs/binary-serializer"
	/>
</CardGrid>
