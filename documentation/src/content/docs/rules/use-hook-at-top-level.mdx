---
title: use-hook-at-top-level
---

Enforces that React hooks are only called at the top level of components or custom hooks, never conditionally or in nested functions.

## Rule Details

React's Rules of Hooks require that hooks are called:

1. At the top level (not in loops, conditions, or nested functions)
2. In the same order every render
3. Only in React function components or custom hooks

**External Documentation**: [React Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks)

## Options

```jsonc
{
	"cease-nonsense/use-hook-at-top-level": [
		"error",
		{
			// Strategy 1: Ignore specific hooks by name
			"ignoreHooks": ["useEntity", "useComponent"],

			// Strategy 2: Control by import source
			"importSources": {
				"react": true, // Check hooks from React
				"my-ecs-library": false, // Ignore ECS hooks
			},

			// Strategy 3: Whitelist mode (only check these)
			"onlyHooks": ["useState", "useEffect", "useContext"],
		},
	],
}
```

### Configuration Parameters

- **ignoreHooks** (default: `[]`): Array of hook names to ignore
- **importSources** (default: `{}`): Object mapping import sources to boolean (check or ignore)
- **onlyHooks** (default: `[]`): Whitelist of hooks to check (ignores all others)

## Examples

### ❌ Incorrect

```typescript
function UserProfile({ userId }) {
	// Conditional hook call
	if (userId) {
		useEffect(() => {
			fetchUser(userId);
		}, [userId]); // ERROR: hook in conditional
	}

	// Hook in loop
	for (const id of ids) {
		const user = useUser(id); // ERROR: hook in loop
	}

	// Hook in nested function
	function handleClick() {
		const [clicked, setClicked] = useState(false); // ERROR: hook in nested function
	}

	// Hook in callback
	useEffect(() => {
		const [data, setData] = useState(null); // ERROR: hook in callback
	}, []);

	// Early return before hook
	if (!userId) return null;
	const user = useUser(userId); // ERROR: hook after conditional return

	return <div>{user.name}</div>;
}
```

### ✅ Correct

```typescript
function UserProfile({ userId }) {
	// Hooks at top level
	const user = useUser(userId);
	const [isOpen, setIsOpen] = useState(false);

	useEffect(() => {
		// Condition inside hook (not around it)
		if (userId) {
			fetchUser(userId);
		}
	}, [userId]);

	// Hook before early return
	if (!user) return null;

	return <div>{user.name}</div>;
}

// Nested function without hooks is fine
function Component() {
	const [count, setCount] = useState(0);

	function handleClick() {
		setCount((c) => c + 1); // Using setState (not calling hook)
	}

	return <button onClick={handleClick}>{count}</button>;
}
```

## Why This Rule Exists

### Order Consistency

React relies on hook call order to maintain state:

```typescript
function Component({ condition }) {
	// Render 1: useState called first
	const [a, setA] = useState(1);

	if (condition) {
		// Render 2: this hook might not be called
		const [b, setB] = useState(2); // Hook order changes!
	}

	// React's internal state array gets misaligned
}
```

### State Corruption

Inconsistent hook calls corrupt React's internal state:

```typescript
// First render (condition = true)
// React's state: [stateA, stateB, stateC]

// Second render (condition = false)
// React's state: [stateA, stateC] // stateB skipped!
// React thinks stateC is stateB → corruption
```

### Correct Patterns

```typescript
function Component({ condition }) {
	// ✅ Always call hooks
	const [a, setA] = useState(1);
	const [b, setB] = useState(2);

	// Put condition logic inside hook effects
	useEffect(() => {
		if (condition) {
			// Conditional logic here
		}
	}, [condition]);

	return <div />;
}
```

## Common Mistakes

### Conditional Mounting

```typescript
// ❌ Wrong: conditional hook
function Component({ showFeature }) {
	if (showFeature) {
		const feature = useFeature(); // ERROR
	}
}

// ✅ Right: always call hook, use conditionally
function Component({ showFeature }) {
	const feature = useFeature();

	if (!showFeature) return null;

	return <div>{feature.name}</div>;
}
```

### Loops

```typescript
// ❌ Wrong: hook in loop
function UserList({ userIds }) {
	return userIds.map((id) => {
		const user = useUser(id); // ERROR
		return <div>{user.name}</div>;
	});
}

// ✅ Right: extract component
function UserItem({ userId }) {
	const user = useUser(userId); // Hook at top level
	return <div>{user.name}</div>;
}

function UserList({ userIds }) {
	return userIds.map((id) => <UserItem key={id} userId={id} />);
}
```

### Early Returns

```typescript
// ❌ Wrong: hook after conditional return
function Component({ data }) {
	if (!data) return null; // Early return
	const processed = useProcessData(data); // ERROR: might not be called
	return <div>{processed}</div>;
}

// ✅ Right: hook before conditional return
function Component({ data }) {
	const processed = useProcessData(data); // Always called
	if (!processed) return null;
	return <div>{processed}</div>;
}
```

## Custom Hooks

Custom hooks must also follow these rules:

```typescript
// ✅ Correct custom hook
function useUserData(userId: string) {
	const [user, setUser] = useState(null);

	useEffect(() => {
		if (userId) {
			fetchUser(userId).then(setUser);
		}
	}, [userId]);

	return user;
}

// ❌ Wrong: conditional hook in custom hook
function useBadHook(condition: boolean) {
	if (condition) {
		const [state, setState] = useState(0); // ERROR
	}
}
```

## Ignoring Non-React Hooks

Some libraries use `use` prefix but aren't React hooks:

```typescript
{
  "ignoreHooks": ["useEntity", "useComponent"],  // ECS library hooks
  "importSources": {
    "react": true,
    "@rbxts/react-reflex": true,
    "my-ecs-lib": false  // Not React hooks
  }
}
```

```typescript
// Ignored (ECS library, not React)
function System() {
	for (const entity of entities) {
		const component = useComponent(entity); // OK (ignored)
	}
}
```

## Exception: Test Utilities

Test utilities that use `use` prefix aren't subject to this rule:

```typescript
// In tests, this is fine
test("my test", () => {
	if (condition) {
		const result = useTestHelper(); // Test utility, not React hook
	}
});
```

## When Not To Use It

If you're not using React or are using a library with `use`-prefixed functions that aren't React hooks, configure the rule to ignore those patterns or disable it entirely.

## Related Rules

- [use-exhaustive-dependencies](./use-exhaustive-dependencies.md) - Ensures correct dependency arrays
- [require-named-effect-functions](./require-named-effect-functions.md) - Enforces named effect callbacks

## Further Reading

- [React Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks)
- [ESLint Plugin React Hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)
- [Why Hooks Order Matters](https://react.dev/warnings/invalid-hook-call-warning)
