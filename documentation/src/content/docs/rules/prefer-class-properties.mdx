---
title: prefer-class-properties
---

Prefer class properties over assignment of literals in constructors.

## Rule Details

This rule enforces using class property declarations for literal values instead of assigning them in the constructor. Class properties are more concise, clearer in intent, and better match modern JavaScript/TypeScript style.

## Options

```jsonc
{
	"cease-nonsense/prefer-class-properties": ["error", "always"],
}
```

### Option Values

- `"always"` (default): Prefer class properties for literals
- `"never"`: Disallow class properties (prefer constructor assignments)

## Examples

### ❌ Incorrect (with `"always"`)

```typescript
class User {
	constructor() {
		this.name = "Unknown"; // Literal in constructor
		this.age = 0;
		this.active = true;
		this.roles = ["user"];
		this.config = { theme: "dark" };
	}
}
```

```typescript
class Component {
	constructor() {
		this.id = `component-${Math.random()}`; // Still literal-like
		this.element = document.createElement("div");
		this.data = {
			x: 0,
			y: 0,
		};
	}
}
```

### ✅ Correct (with `"always"`)

```typescript
class User {
	name = "Unknown"; // Class property
	age = 0;
	active = true;
	roles = ["user"];
	config = { theme: "dark" };
}
```

```typescript
class Component {
	id = `component-${Math.random()}`;
	element = document.createElement("div");
	data = {
		x: 0,
		y: 0,
	};
}
```

```typescript
class Example {
	// Constructor assignments are OK for non-literals
	constructor(config: Config) {
		this.config = config; // Not a literal
		this.handler = this.createHandler(); // Method call
	}
}
```

### ❌ Incorrect (with `"never"`)

```typescript
class User {
	name = "Unknown"; // Class property not allowed
	age = 0;
}
```

### ✅ Correct (with `"never"`)

```typescript
class User {
	constructor() {
		this.name = "Unknown";
		this.age = 0;
	}
}
```

## What is Considered a "Simple Literal"?

The rule considers these as simple literals:

### Primitive Literals

```typescript
class Example {
	// ❌ Should be class properties
	constructor() {
		this.string = "hello";
		this.number = 42;
		this.boolean = true;
		this.nullValue = null;
	}
}
```

### Object Literals

```typescript
class Example {
	// ❌ Should be class property
	constructor() {
		this.config = {
			x: 10,
			y: 20,
			nested: {
				a: 1,
			},
		};
	}
}
```

### Array Literals

```typescript
class Example {
	// ❌ Should be class property
	constructor() {
		this.items = [1, 2, 3];
		this.nested = [
			[1, 2],
			[3, 4],
		];
	}
}
```

### Static Member Expressions

```typescript
class Example {
	// ❌ Should be class property
	constructor() {
		this.color = Color3.fromRGB(255, 0, 0);
		this.vector = Vector3.zero;
	}
}
```

## What is NOT Considered?

### Constructor Parameters

```typescript
class Example {
	// ✅ Allowed - not a literal
	constructor(name: string) {
		this.name = name;
	}
}
```

### Method Calls

```typescript
class Example {
	// ✅ Allowed - method call result
	constructor() {
		this.id = generateId();
		this.handler = this.createHandler();
	}
}
```

### Dynamic Property Access

```typescript
class Example {
	// ✅ Allowed - computed property
	constructor() {
		this.value = obj[key];
	}
}
```

### Non-This Assignments

```typescript
class Example {
	// ✅ Allowed - not assigning to this
	constructor() {
		const temp = "value";
		someObject.prop = "value";
	}
}
```

## Benefits of Class Properties

### 1. Clarity and Readability

```typescript
// ❌ Harder to see class structure
class User {
	constructor() {
		this.name = "";
		this.email = "";
		this.age = 0;
		this.active = true;
	}
}

// ✅ Class structure immediately visible
class User {
	name = "";
	email = "";
	age = 0;
	active = true;
}
```

### 2. Less Boilerplate

```typescript
// ❌ Requires constructor
class Config {
	constructor() {
		this.timeout = 5000;
		this.retries = 3;
		this.debug = false;
	}
}

// ✅ No constructor needed
class Config {
	timeout = 5000;
	retries = 3;
	debug = false;
}
```

### 3. Better TypeScript Integration

```typescript
// ✅ TypeScript infers types from initializers
class Point {
	x = 0; // TypeScript knows this is number
	y = 0;
}

// vs requiring explicit types
class Point {
	x: number;
	y: number;

	constructor() {
		this.x = 0;
		this.y = 0;
	}
}
```

### 4. Clearer Inheritance

```typescript
class Base {
	baseProp = "base";
}

class Derived extends Base {
	derivedProp = "derived";

	// Constructor only needed if doing non-literal work
}
```

## Advanced Examples

### Mixed Assignments

```typescript
class Component {
	// Class properties for literals
	id = generateId();
	defaultSize = new Vector2(100, 100);
	config = {
		enabled: true,
		theme: "dark",
	};

	// Constructor for dynamic values
	constructor(options: Options) {
		this.options = options;
		this.handler = this.createHandler(options);
	}

	private createHandler(options: Options) {
		// ...
	}
}
```

### With Visibility Modifiers

```typescript
class Service {
	// Public class properties
	public name = "ServiceName";
	public version = "1.0.0";

	// Private class properties
	private cache = new Map();
	private initialized = false;

	// Protected class properties
	protected config = {
		timeout: 5000,
	};
}
```

### With Readonly

```typescript
class Constants {
	readonly MAX_SIZE = 100;
	readonly DEFAULT_COLOR = Color3.fromRGB(255, 255, 255);
	readonly CONFIG = {
		key: "value",
	};
}
```

## Edge Cases

### Computed Property Names

```typescript
class Example {
	// ✅ Class properties support computed names (but rare)
	["computed" + "Name"] = "value";
}
```

### Decorators

```typescript
class Component {
	// ✅ Can use decorators with class properties
	@observable
	count = 0;

	@computed
	get doubled() {
		return this.count * 2;
	}
}
```

## When Not To Use It

Consider using `"never"` option if:

- Your codebase consistently uses constructor assignment
- You're working with a style guide that requires constructor initialization
- You need to maintain compatibility with older JavaScript environments

## Configuration Examples

### Enforce Class Properties (Default)

```typescript
{
  "cease-nonsense/prefer-class-properties": ["error", "always"]
}
```

### Disallow Class Properties

```typescript
{
  "cease-nonsense/prefer-class-properties": ["error", "never"]
}
```

### Warn Instead of Error

```typescript
{
  "cease-nonsense/prefer-class-properties": ["warn", "always"]
}
```

## Migration Guide

### Automated Migration

Most cases can be automatically refactored:

1. Find all constructor assignments of literals
2. Move them to class property declarations
3. Remove constructor if it becomes empty

```typescript
// Before:
class Example {
	constructor() {
		this.a = 1;
		this.b = 2;
	}

	method() {
		/* ... */
	}
}

// After:
class Example {
	a = 1;
	b = 2;

	method() {
		/* ... */
	}
}
```

### Handling Computed Values

```typescript
// Before:
class Component {
	constructor() {
		this.id = `id-${Math.random()}`;
		this.timestamp = Date.now();
	}
}

// After (computed per instance):
class Component {
	id = `id-${Math.random()}`;
	timestamp = Date.now();
}
```

**Note**: Class property initializers run once per instance, maintaining correct behavior.

## Related Rules

- [no-async-constructor](./no-async-constructor.md) - Prevents async operations in constructors
- [prefer-module-scope-constants](./prefer-module-scope-constants.md) - Enforces module-level constants

## Further Reading

- [TC39 Class Fields Proposal](https://github.com/tc39/proposal-class-fields)
- [TypeScript Class Members](https://www.typescriptlang.org/docs/handbook/2/classes.html)
- [MDN: Class Fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields)
