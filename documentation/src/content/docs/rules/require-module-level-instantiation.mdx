---
title: require-module-level-instantiation
---

Require certain classes to be instantiated at module level rather than inside functions.

## Rule Details

Some classes, like logging utilities, should be instantiated once at module scope rather than recreated on every function call. This prevents wasted resources and potential unexpected behavior from multiple instances.

## Options

```jsonc
{
	"cease-nonsense/require-module-level-instantiation": [
		"error",
		{
			"classes": {
				"Log": "@rbxts/rbxts-sleitnick-log",
				"Server": "@rbxts/net",
			},
		},
	],
}
```

### `classes`

A mapping of class names to their expected import sources. Only classes imported from the specified source will be checked.

## Examples

### Incorrect

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

function useStoryModesState() {
	const log = new Log(); // Recreated on every call!
	log.Info("Create Match clicked");
}
```

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

const handler = () => {
	const log = new Log(); // Inside arrow function
};
```

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

class MyClass {
	doThing() {
		const log = new Log(); // Inside method
	}
}
```

### Correct

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

const log = new Log(); // Module level - created once

function useStoryModesState() {
	log.Info("Create Match clicked");
}
```

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

const log = new Log();

const handler = () => {
	log.Info("Handler called");
};
```

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";

const log = new Log();

class MyClass {
	doThing() {
		log.Info("Doing thing");
	}
}
```

## Why This Rule Exists

### Performance

Instantiating objects inside functions means creating a new instance on every call:

```typescript
// Calling this 100 times creates 100 Log instances
function process() {
	const log = new Log();
	log.Info("Processing");
}
```

vs.

```typescript
const log = new Log(); // Created once

// Calling this 100 times uses the same Log instance
function process() {
	log.Info("Processing");
}
```

### Resource Management

Some classes maintain internal state, connections, or resources. Multiple instances may:

- Compete for resources
- Create duplicate connections
- Cause inconsistent behavior

### Singleton Pattern

Many utility classes like loggers are designed to be used as singletons. Recreating them defeats this design.

## Configuration Examples

### Single Class

```typescript
{
  "cease-nonsense/require-module-level-instantiation": ["error", {
    "classes": {
      "Log": "@rbxts/rbxts-sleitnick-log"
    }
  }]
}
```

### Multiple Classes

```typescript
{
  "cease-nonsense/require-module-level-instantiation": ["error", {
    "classes": {
      "Log": "@rbxts/rbxts-sleitnick-log",
      "Server": "@rbxts/net",
      "Client": "@rbxts/net"
    }
  }]
}
```

## Import Handling

The rule tracks imports and only flags instantiations of classes imported from the configured source.

### Default Imports

```typescript
import Log from "@rbxts/rbxts-sleitnick-log";
// new Log() inside functions will be flagged
```

### Named Imports

```typescript
import { Logger } from "@company/logging";
// new Logger() inside functions will be flagged if configured
```

### Aliased Imports

```typescript
import { Logger as Log } from "@company/logging";
// new Log() inside functions will be flagged if Logger is configured
```

### Namespace Imports

```typescript
import * as Logging from "@rbxts/rbxts-sleitnick-log";
// new Logging.Log() inside functions will be flagged
```

## When Not To Use It

- If you need different instances with different configurations
- If the class is designed to be instantiated per-use
- If you're working with classes that don't have shared state concerns

## Related Rules

- [prefer-module-scope-constants](./prefer-module-scope-constants.md) - Similar concept for constants
