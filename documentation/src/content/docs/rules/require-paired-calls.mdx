---
title: require-paired-calls
---

Enforces that paired function calls (opener/closer) are properly balanced across all execution paths with LIFO (Last In, First Out) ordering.

## Rule Details

This rule ensures resource management patterns like profiling markers, database transactions, and locks are properly paired. It validates that:

1. Every opener has a matching closer
2. Closers are called in LIFO order (like stack unwinding)
3. All code paths include the closer (no early returns without cleanup)
4. Optional sync requirements prevent async operations between pairs

## Options

```jsonc
{
	"cease-nonsense/require-paired-calls": [
		"error",
		{
			"pairs": [
				{
					"opener": "debug.profilebegin",
					"closer": "debug.profileend",
					"alternatives": ["db.rollback"],
					"requireSync": true,
					"platform": "roblox",
					"yieldingFunctions": ["task.wait", "*.WaitForChild"],
				},
			],
			"allowConditionalClosers": false,
			"allowMultipleOpeners": true,
			"maxNestingDepth": 0,
		},
	],
}
```

### Pair Configuration

- **opener** (required): Function name that starts the paired operation
- **openerAlternatives** (optional): Additional opener names sharing the same closer
- **closer** (required): Function name(s) that close the operation (string or array)
- **alternatives** (optional): Alternative closers for error paths (e.g., rollback)
- **requireSync** (optional): Disallow `await`/`yield` between opener and closer
- **platform** (optional): Platform-specific behavior (`"roblox"`)
- **yieldingFunctions** (optional): Patterns for Roblox yielding functions (supports wildcards like `*.WaitForChild`)

### Top-Level Options

- **pairs** (required): Array of pair configurations
- **allowConditionalClosers** (optional): Allow closers in some but not all branches
- **allowMultipleOpeners** (optional): Allow consecutive opener calls without closers
- **maxNestingDepth** (optional): Maximum nesting depth (0 = unlimited)

## Examples

### ❌ Incorrect

```typescript
// Missing closer on early return
function test() {
	debug.profilebegin("task");
	if (error) return; // Never closed!
	debug.profileend();
}

// Wrong LIFO order
function test() {
	debug.profilebegin("outer");
	debug.profilebegin("inner");
	debug.profileend(); // closes inner
	// outer is never closed
}

// Async operation with requireSync
async function test() {
	debug.profilebegin("task");
	await fetch("/api"); // Violates requireSync
	debug.profileend();
}

// Closer in only one branch
function test() {
	debug.profilebegin("task");
	if (condition) {
		debug.profileend();
	}
	// Missing closer on else branch
}

// Roblox: yielding call between pairs
function test() {
	debug.profilebegin("task");
	task.wait(1); // Yields, breaks sync requirement
	debug.profileend();
}
```

### ✅ Correct

```typescript
// Simple pairing
function test() {
	debug.profilebegin("task");
	doWork();
	debug.profileend();
}

// Proper LIFO nesting
function test() {
	debug.profilebegin("outer");
	debug.profilebegin("inner");
	debug.profileend(); // closes inner
	debug.profileend(); // closes outer
}

// Try-finally ensures closer on all paths
function test() {
	debug.profilebegin("task");
	try {
		riskyOperation();
	} finally {
		debug.profileend();
	}
}

// Alternative closer for error path
async function test() {
	await db.transaction();
	try {
		await db.query("INSERT ...");
		await db.commit();
	} catch {
		await db.rollback(); // Alternative closer
	}
}

// Multiple openers with allowMultipleOpeners
function test() {
	debug.profilebegin("task1");
	debug.profilebegin("task2");
	debug.profileend();
	debug.profileend();
}
```

## Real-World Examples

### Database Transactions

```typescript
{
  "pairs": [{
    "opener": "db.transaction",
    "closer": "db.commit",
    "alternatives": ["db.rollback"]
  }]
}
```

```typescript
async function updateUser(id: number, data: UserData) {
	await db.transaction();
	try {
		await db.query("UPDATE users SET ...", data);
		await db.commit();
	} catch (error) {
		await db.rollback();
		throw error;
	}
}
```

### Lock Acquire/Release

```typescript
{
  "pairs": [{
    "opener": "lock.acquire",
    "closer": ["lock.release", "lock.free"]
  }]
}
```

```typescript
async function criticalSection() {
	await lock.acquire();
	try {
		await modifySharedResource();
	} finally {
		lock.release();
	}
}
```

### Roblox Iris UI

```typescript
{
  "pairs": [{
    "opener": "Iris.CollapsingHeader",
    "openerAlternatives": ["Iris.Window", "Iris.TreeNode", "Iris.Table"],
    "closer": "Iris.End",
    "platform": "roblox",
    "requireSync": true
  }]
}
```

```typescript
function renderUI() {
	if (Iris.CollapsingHeader("Section")) {
		Iris.Text("Content");
		Iris.End();
	}
}
```

## Platform-Specific Behavior

### Roblox Platform

When `platform: "roblox"` is set, the rule detects yielding functions that break synchronous execution:

- Built-in: `task.wait`, `wait`
- Patterns: `*.WaitForChild`, `*.WaitFor*`
- Custom patterns via `yieldingFunctions` option

```typescript
// Violates Roblox sync requirement
function badCode() {
	debug.profilebegin("task");
	const part = workspace.WaitForChild("Part"); // Yields!
	debug.profileend();
}

// Correct: no yielding
function goodCode() {
	debug.profilebegin("task");
	const part = workspace.FindFirstChild("Part");
	debug.profileend();
}
```

## When Not To Use It

If your codebase doesn't use paired resource management patterns, this rule isn't applicable. Disable it or configure specific pairs for your use case.

## Related Rules

- [react-hooks-strict-return](./react-hooks-strict-return.md) - Enforces hook return value patterns

## Further Reading

- [Resource Acquisition Is Initialization (RAII)](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)
- [Roblox Profiling Best Practices](https://create.roblox.com/docs/scripting/performance-optimization/profiling)
