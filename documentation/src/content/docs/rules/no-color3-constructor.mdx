---
title: no-color3-constructor
---

Bans `new Color3(...)` except for `new Color3()` or `new Color3(0, 0, 0)`. Use `Color3.fromRGB()` instead.

## Rule Details

The `new Color3()` constructor uses floating-point values in the range [0-1] and performs worse than `Color3.fromRGB()` which uses integer values [0-255]. This rule enforces the use of the more performant `Color3.fromRGB()` method while allowing the zero-argument constructor and explicit zero values.

## Options

This rule has no configuration options.

## Examples

### ❌ Incorrect

```typescript
// Using float values
const red = new Color3(1, 0, 0);
const blue = new Color3(0.5, 0.5, 1);
const green = new Color3(0, 255, 0);

// Partial arguments
const white = new Color3(1, 1);
const gray = new Color3(0.5);
```

### ✅ Correct

```typescript
// Use Color3.fromRGB() instead
const red = Color3.fromRGB(255, 0, 0);
const blue = Color3.fromRGB(127, 127, 255);
const green = Color3.fromRGB(0, 255, 0);

// Zero constructors are allowed
const black = new Color3(0, 0, 0);
const alsoBlack = new Color3();

// Using named constants
const white = Color3.fromRGB(255, 255, 255);
```

## Auto-Fix Behavior

This rule provides automatic fixes that convert float values to RGB integers:

```typescript
// Before:
const pink = new Color3(1, 0.75, 0.8);

// After (auto-fixed):
const pink = Color3.fromRGB(255, 191, 204);
```

### Float Conversion

The rule automatically converts float values [0-1] to integers [0-255]:

- Values > 1 are treated as already being in [0-255] range
- Values ≤ 1 are multiplied by 255 and rounded

```typescript
// Float to RGB conversion:
new Color3(1, 0, 0) → Color3.fromRGB(255, 0, 0);
new Color3(0.5, 0.5, 0.5) → Color3.fromRGB(127, 127, 127);

// Already RGB values (no multiplication):
new Color3(128, 64, 32) → Color3.fromRGB(128, 64, 32);
```

## Performance Benefits

### Execution Speed

`Color3.fromRGB()` is faster than `new Color3()` because:

1. **No float-to-int conversion** - Roblox engine converts [0-1] floats to [0-255] internally
2. **Direct integer storage** - RGB values are stored as integers in the engine
3. **Optimized code path** - `fromRGB()` uses a faster internal implementation

### Memory Efficiency

```typescript
// Less efficient - float representation
const color1 = new Color3(0.5, 0.5, 0.5);

// More efficient - integer representation
const color2 = Color3.fromRGB(127, 127, 127);
```

## Common Patterns

### Color Palettes

```typescript
// ❌ Bad
const COLORS = {
	PRIMARY: new Color3(0.2, 0.4, 0.8),
	SECONDARY: new Color3(0.8, 0.2, 0.4),
	ACCENT: new Color3(0, 0.9, 0.5),
};

// ✅ Good
const COLORS = {
	PRIMARY: Color3.fromRGB(51, 102, 204),
	SECONDARY: Color3.fromRGB(204, 51, 102),
	ACCENT: Color3.fromRGB(0, 229, 127),
};
```

### Dynamic Colors

```typescript
// ❌ Bad
function createGradient(start: number, end: number, steps: number) {
	const colors = [];
	for (let i = 0; i < steps; i++) {
		const ratio = i / (steps - 1);
		colors.push(new Color3(ratio, ratio, ratio));
	}
	return colors;
}

// ✅ Good
function createGradient(start: number, end: number, steps: number) {
	const colors = [];
	for (let i = 0; i < steps; i++) {
		const ratio = i / (steps - 1);
		const value = Math.round(ratio * 255);
		colors.push(Color3.fromRGB(value, value, value));
	}
	return colors;
}
```

### Color Interpolation

```typescript
// ❌ Bad
function lerp(a: Color3, b: Color3, t: number): Color3 {
	return new Color3(a.R + (b.R - a.R) * t, a.G + (b.G - a.G) * t, a.B + (b.B - a.B) * t);
}

// ✅ Good
function lerp(a: Color3, b: Color3, t: number): Color3 {
	return Color3.fromRGB(
		Math.round(a.R * 255 + (b.R - a.R) * t * 255),
		Math.round(a.G * 255 + (b.G - a.G) * t * 255),
		Math.round(a.B * 255 + (b.B - a.B) * t * 255),
	);
}
```

## Edge Cases

### Non-Numeric Arguments

The rule only applies to numeric literals:

```typescript
// Not checked (variables)
const r = 0.5;
const color = new Color3(r, r, r); // No error

// Not checked (expressions)
const color2 = new Color3(Math.random(), 0, 0); // No error

// Checked (literals only)
const color3 = new Color3(0.5, 0.5, 0.5); // ❌ Error
```

### Partial Arguments

Missing arguments are treated as 0:

```typescript
// Before:
new Color3(10, 5);

// After (auto-fixed):
Color3.fromRGB(10, 5, 0);
```

### Mixed Float and Integer

The rule handles mixed value ranges correctly:

```typescript
// Before:
new Color3(1, 128, 0.5);

// After (auto-fixed):
Color3.fromRGB(255, 128, 127);
```

## When Not To Use It

This rule is Roblox-specific. Disable it if:

- You're not working with Roblox/roblox-ts
- You're working with a codebase that extensively uses float colors and requires gradual migration
- You have performance measurements showing `new Color3()` is acceptable for your use case

## Migration Guide

### Find and Replace

```bash
# Find all Color3 constructor calls
grep -r "new Color3" --include="*.ts" --include="*.tsx"
```

### Automated Fix

```bash
# Fix all violations automatically
bun run lint:fix
eslint --fix src/
```

### Manual Conversion Table

| Float Input | RGB Output |
| ----------- | ---------- |
| 0.0         | 0          |
| 0.25        | 64         |
| 0.5         | 127        |
| 0.75        | 191        |
| 1.0         | 255        |

## Related Rules

- [prefer-udim2-shorthand](/rules/prefer-udim2-shorthand/) - Similar performance rule for UDim2
- [prefer-sequence-overloads](/rules/prefer-sequence-overloads/) - Optimized sequence constructors
- [prefer-pattern-replacements](/rules/prefer-pattern-replacements/) - General constructor optimization

## Further Reading

- [Roblox Color3 API](https://create.roblox.com/docs/reference/engine/datatypes/Color3)
- [Roblox Performance Optimization](https://create.roblox.com/docs/scripting/performance-optimization)
- [Color Theory for Game Development](https://gamedevbeginner.com/the-ultimate-guide-to-color-in-game-art/)
